//	 저장된 데이터를 읽는것 : getter
//	 데이터를 저장하기 위한것 : setter- 이게 선행되어야 한다 그래야 lora에 setter를 하고 print에서 getter가 가능


이거 해석해보기:
	ScoreDto sdto;
	List<ScoreDto> list= new ArrayList();
	public void makeScore() {
		for (int i = 0; i < 10; i++) {
			sdto= new ScoreDto();
			sdto.setStName("%03d");---이거 이름 바꾸는 것도 format으로 하는데 어떻게 하는지 확인
			sdto.setScKor((int)(Math.random()*50)+51);
			sdto.setScEng((int)(Math.random()*50)+51);
			sdto.setScMath((int)(Math.random()*50)+51);
			list.add(sdto);
		}

		배열은 새로 선언하면 기존의 배열은 사라지고 새로 만들어진다

interface

		interface에서 만들어진 메서드는 그걸을 implement하는 클래스에게 interface에서 사용한 메서드를
		무조건 같게 사용해야하는 강제성을 가진다. 


.split

		// 문자열변수(문자열데이터).split("구분자")
		// 문자열 변수에 저장된 문자열을 "구분자" 로 구분하여
		//	문자열 배열로 생성해주는 method
		String[] student= StdData.STUDENT[0].split(",");
	

		java 프로젝트 16  impl 패키지 StudentServiceimplV1 클래스 다시


확장된for

		for(type a:score){		
		}
		- 어떤 타입을 가지는 a를 socre만큼 반복한다.
		이때 a에 socre가 가진 객체를 사용 가능

substring ( x , y )
			x~y까지 글자수를 출력한다

trim()
		문자형변수 뒤에 붙는 명령어로 빈칸을 없애준다
		ex) "   13531" - 라는 글자를 Integer.value로 숫자로 바꿀때 빈칸이 있어 변경이 안된다 그러니
		Integer.value.trim(); 이렇게 뒤에 붙여준다


%s(문자), %d(정수),  %f(실수)
		"%03d"  는 3칸을 만들고 d를 오른쪽부터 정렬한다
		"%-03d"	는 3칸을 만들고 d를 왼쪽부터 정렬한다.







